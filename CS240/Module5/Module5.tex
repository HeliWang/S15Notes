\documentclass[12pt]{article}

\setlength\parindent{0pt}
\newcommand{\myt}[1]{\textbf{\underline{#1}}}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{tikz,ifthen,amsmath,amssymb,fancyhdr,comment,lastpage}

\title{\vspace{-15ex}Module 5 - Hashing\vspace{-1ex}}
\date{June 16th, 2015}
\author{Graham Cooper}

\begin{document}
	\maketitle
	\section*{Search in a dictionary of n items}
	\begin{itemize}
		\item Unsorted array $\Theta(n)$
		\item sorted array $\Theta(logn)$
		\item AVL Tree $\Theta(logn)$
		\item B-tree $\Theta(logn)$
	\end{itemize}
	
	\subsection*{Can we do better than $\Theta(logn)?$}
	\subsubsection*{Comparison Based Model}
	NO\\
	In a comparison based model\\
	\begin{itemize}
		\item A search algorithm is a binary decision tree
		\item Each internal node is a comparison
		\item each leaf is a set of actionss
		\item each instance (output) requires different actions
		\item n+1 possible outputs.
	\end{itemize}
	
	A binary decision tree with n+1 leaves\\
	- The height of the tree (the number of required comparisons) is $\Omega(logn)$\\
	
	\subsection{Direct accessing}
	- On implementation of Dictionary A.D.T. we have n item with integer keys which are $<$ M\\
	insert(3,John)\\
	insert(5, andrew)\\
	insert(6, shahini)
	
	\subsection*{Hashing}
	A dictionary of n items with numerical keys\\
	-A hash table of size M, a hash function $\rightarrow$ maps each key to an integer in the range [0,M]\\
	- To search, insert, delete look at the mapped index in a hash table\\
	
	Assume M = 7,\\
	--keys are integers and h(k) = j mod 7
	-- insert(26, "john") $\rightarrow$ h(26) = 5\\
	-- insert(39, "hi") $\rightarrow$ h(39) = 4\\
	insert(21, "blah") $\rightarrow$ h(21) = 0\\
	insert(35, "STFF") $\rightarrow$ h(35) = 0\\
	
	Collision $\rightarrow$ when two keys in dictinoary share the same index in the hash table
	Load factor $\alpha = \frac{n}{M}$\\
	It can be $>$ 1 $<=$ 1, $\alpha$ should be constant (independent of n, m)\\
	
	A table of size m, n changes by insertion deletions,\\
	- When load factor becomes too large - too many collisions, slower operation\\
	- Too small - space waste
	In both cases we should do a rehash\\
	
	\subsubsection*{Collision Handling - Chaining}
	h(k) = k mod 7\\
	insert(39) - h(39) =4\\
	insert(3) - h(3) = 4\\
	insert(36) - h(36) = 1\\
	insert(6) - h(6) = 6\\
	insert(20) - h(20) = 6\\
	
	We create a linked list, the start is 6, then 20\\
	Getting a vlue from the linked list is still O(1) since the load balance maeans there are nota lot of collisions\\
	
	\subsubsection*{Average length of lists}
	$\exists$ are n items with m indices\\
	If the hash function distributes items equally between indices, each bucket has $\frac{n}{m} = \alpha$ items\\
	
	Time  complexity of n\\
	search O(1 + $\alpha$)\\
	insert - O(1)\\
	delete = O(1 + $\alpha$)\\
	
	
	\subsection*{Open addressing}
	Each key has a set of candidate indices h(k,0), h(k,1), ... h(k,i)\\
	
	\subsubsection*{Linear Hashing}
	h(k,i) = (h(k) + i) mod M\\
	$\implies$ h(k,0) = k(k)\\
	h(k,1) = h(k) + 1\\
	
	M = 7, h(k) = k mod 7
	insert(6)\\
	insert(4)\\
	insert(0)\\
	insert(2)\\
	insert(17) - h(17) = 3\\
	insert(7) - h(7) = 0\\
	insert(7,b) = h(7) = 0 (is it available, no)\\
	h(7,1) = (h(7) + 1) mod 7 = 1 (good)\\
	insert(16) - h(16,0) = h(16) = 2 (bad)\\
	insert(16,1) - (h(16) + 1) = 3 (bad)\\
	insert(16,2) - h(16) + 2 = 4 - good!\\
	
	M = 7, h(k) = k mod 7\
	insert(2)\\
	insert(3)\\
	insert(9)\\ - h(9) = 2\\
	delete(3)\\
	search(9)\\
	
	We need to mark things as deleted so we do not stop at deleted indexes when we are searching for 9\\
	
\end{document}
